<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Assembly · JuAFEM.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuAFEM.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><a class="toctext" href="../fe_intro/">Introduction to FEM</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../cell_integration/">Cell Integration</a></li><li><a class="toctext" href="../degrees_of_freedom/">Degrees of Freedom</a></li><li class="current"><a class="toctext" href>Assembly</a><ul class="internal"><li><a class="toctext" href="#Sparsity-Pattern-1">Sparsity Pattern</a></li><li><a class="toctext" href="#Assembler-1"><code>Assembler</code></a></li></ul></li><li><a class="toctext" href="../boundary_conditions/">Boundary Conditions</a></li><li><a class="toctext" href="../grid/">Grid</a></li><li><a class="toctext" href="../export/">Export</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/generated/heat_equation/">Heat Equation</a></li><li><a class="toctext" href="../../examples/generated/incompressible_elasticity/">Incompressible Elasticity</a></li><li><a class="toctext" href="../../examples/generated/hyperelasticity/">Hyperelasticity</a></li><li><a class="toctext" href="../../examples/generated/threaded_assembly/">Threaded Assembly</a></li><li><a class="toctext" href="../../examples/generated/plasticity/">von Mises plasticity</a></li></ul></li><li><span class="toctext">API Reference</span><ul><li><a class="toctext" href="../../reference/quadrature/">Quadrature</a></li><li><a class="toctext" href="../../reference/interpolations/">Interpolation</a></li><li><a class="toctext" href="../../reference/fevalues/">FEValues</a></li><li><a class="toctext" href="../../reference/dofhandler/">DofHandler</a></li><li><a class="toctext" href="../../reference/assembly/">Assembly</a></li><li><a class="toctext" href="../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="toctext" href="../../reference/grid/">Grid</a></li><li><a class="toctext" href="../../reference/export/">Export</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Assembly</a></li></ul><a class="edit-page" href="https://github.com/KristofferC/JuAFEM.jl/blob/master/docs/src/manual/assembly.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Assembly</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Assembly-1" href="#Assembly-1">Assembly</a></h1><p>When the local stiffness matrix and force vector have been calculated they should be assembled into the global stiffness matrix and the global force vector. This is just a matter of adding the local matrix and vector to the global one, at the correct place. Consider e.g. assembling the local stiffness matrix <code>ke</code> and the local force vector <code>fe</code> into the global <code>K</code> and <code>f</code> respectively. These should be assembled into the row/column which corresponds to the degrees of freedom for the cell:</p><pre><code class="language-julia">K[celldofs, celldofs] += ke
f[celldofs]           += fe</code></pre><p>where <code>celldofs</code> is the vector containing the degrees of freedom for the cell. The method above is very inefficient – it is especially costly to index into the sparse matrix <code>K</code> directly. Therefore we will instead use an <code>Assembler</code> that will help with the assembling of both the global stiffness matrix and the global force vector. It is also often convenient to create the sparse matrix just once, and reuse the allocated matrix. This is useful for e.g. iterative solvers or time dependent problems where the sparse matrix structure, or <a href="#Sparsity-Pattern-1">Sparsity Pattern</a> will stay the same in every iteration/ time step.</p><h2><a class="nav-anchor" id="Sparsity-Pattern-1" href="#Sparsity-Pattern-1">Sparsity Pattern</a></h2><p>Given a <code>DofHandler</code> we can obtain the corresponding sparse matrix by using the <a href="../../reference/assembly/#JuAFEM.create_sparsity_pattern"><code>create_sparsity_pattern</code></a> function. This will setup a <code>SparseMatrixCSC</code> with stored values on all the places corresponding to the degree of freedom numbering in the <code>DofHandler</code>. This means that when we assemble into the global stiffness matrix there is no need to change the internal representation of the sparse matrix since the sparse structure will not change.</p><p>Often the finite element problem is symmetric and will result in a symmetric sparse matrix. This information is often something that the sparse solver can take advantage of. If the solver only needs half the matrix there is no need to assemble both halves. For this purpose there is a <a href="../../reference/assembly/#JuAFEM.create_symmetric_sparsity_pattern"><code>create_symmetric_sparsity_pattern</code></a> function that will only create the upper half of the matrix, and return a <code>Symmetric</code> wrapped <code>SparseMatrixCSC</code>.</p><p>Given a <code>DofHandler</code> <code>dh</code> we can obtain the (symmetric) sparsity pattern as</p><pre><code class="language-julia">K = create_sparsity_pattern(dh)
K = create_symmetric_sparsity_pattern(dh)</code></pre><p>The returned sparse matrix will be used together with an <code>Assembler</code>, which assembles efficiently into the matrix, without modifying the internal representation.</p><h2><a class="nav-anchor" id="Assembler-1" href="#Assembler-1"><code>Assembler</code></a></h2><p>Assembling efficiently into the sparse matrix requires some extra workspace. This workspace is allocated in an <code>Assembler</code>. <a href="../../reference/assembly/#JuAFEM.start_assemble"><code>start_assemble</code></a> is used to create an <code>Assembler</code>:</p><pre><code class="language-julia">A = start_assemble(K)
A = start_assemble(K, f)</code></pre><p>where <code>K</code> is the global stiffness matrix, and <code>f</code> the global force vector. It is optional to give the force vector to the assembler – sometimes there is no need to assemble a global force vector.</p><p>fds</p><pre><code class="language-julia">assemble!(A, celldofs, ke)
assemble!(A, celldofs, ke, fe)</code></pre><p>To give a more</p><pre><code class="language-julia">K = create_sparsity_pattern(dh)
f = zeros(ndofs(dh))
A = start_assemble(K, f)

for cell in CellIterator(dh)
    ke, fe = ...
    assemble!(A, celldofs(cell), ke, fe)
end</code></pre><footer><hr/><a class="previous" href="../degrees_of_freedom/"><span class="direction">Previous</span><span class="title">Degrees of Freedom</span></a><a class="next" href="../boundary_conditions/"><span class="direction">Next</span><span class="title">Boundary Conditions</span></a></footer></article></body></html>
