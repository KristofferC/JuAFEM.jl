<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Threaded Assembly · JuAFEM.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>JuAFEM.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><a class="toctext" href="../../../manual/fe_intro/">Introduction to FEM</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../../manual/cell_integration/">Cell Integration</a></li><li><a class="toctext" href="../../../manual/degrees_of_freedom/">Degrees of Freedom</a></li><li><a class="toctext" href="../../../manual/assembly/">Assembly</a></li><li><a class="toctext" href="../../../manual/boundary_conditions/">Boundary Conditions</a></li><li><a class="toctext" href="../../../manual/grid/">Grid</a></li><li><a class="toctext" href="../../../manual/export/">Export</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../heat_equation/">Heat Equation</a></li><li><a class="toctext" href="../incompressible_elasticity/">Incompressible Elasticity</a></li><li class="current"><a class="toctext" href>Threaded Assembly</a><ul class="internal"><li><a class="toctext" href="#Example-of-a-colored-grid-1">Example of a colored grid</a></li><li><a class="toctext" href="#Cantilever-beam-in-3D-with-threaded-assembly-1">Cantilever beam in 3D with threaded assembly</a></li><li><a class="toctext" href="#Threaded-data-structures-1">Threaded data structures</a></li><li><a class="toctext" href="#Threaded-assemble-1">Threaded assemble</a></li><li><a class="toctext" href="#threaded_assembly-plain-program-1">Plain Program</a></li></ul></li></ul></li><li><span class="toctext">API Reference</span><ul><li><a class="toctext" href="../../../reference/quadrature/">Quadrature</a></li><li><a class="toctext" href="../../../reference/interpolations/">Interpolation</a></li><li><a class="toctext" href="../../../reference/fevalues/">FEValues</a></li><li><a class="toctext" href="../../../reference/dofhandler/">DofHandler</a></li><li><a class="toctext" href="../../../reference/assembly/">Assembly</a></li><li><a class="toctext" href="../../../reference/boundary_conditions/">Boundary Conditions</a></li><li><a class="toctext" href="../../../reference/grid/">Grid</a></li><li><a class="toctext" href="../../../reference/export/">Export</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Examples</li><li><a href>Threaded Assembly</a></li></ul><a class="edit-page" href="https://github.com/KristofferC/JuAFEM.jl/blob/master/docs/src/examples/threaded_assembly.jl"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Threaded Assembly</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Threaded-Assembly-1" href="#Threaded-Assembly-1">Threaded Assembly</a></h1><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>This example is also available as a Jupyter notebook: <a href="https://nbviewer.jupyter.org/github/KristofferC/JuAFEM.jl/blob/gh-pages/latest/examples/generated/threaded_assembly.ipynb"><code>threaded_assembly.ipynb</code></a></p></div></div><h2><a class="nav-anchor" id="Example-of-a-colored-grid-1" href="#Example-of-a-colored-grid-1">Example of a colored grid</a></h2><p>Creates a simple 2D grid and colors it. Save the example grid to a VTK file to show the coloring. No cells with the same color has any shared nodes (dofs). This means that it is safe to assemble in parallel as long as we only assemble one color at a time.</p><div><pre><code class="language-julia">using JuAFEM, SparseArrays

function create_example_2d_grid()
    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))
    cell_colors, colors = JuAFEM.create_coloring(grid)
    vtk_grid(&quot;colored&quot;, grid) do vtk
        JuAFEM.vtk_cell_data_colors(vtk, grid, colors)
    end
end;

create_example_2d_grid()</code></pre><pre><code class="language-none">1-element Array{String,1}:
 &quot;colored.vtu&quot;</code></pre></div><p><img src="../coloring.png" alt/></p><h2><a class="nav-anchor" id="Cantilever-beam-in-3D-with-threaded-assembly-1" href="#Cantilever-beam-in-3D-with-threaded-assembly-1">Cantilever beam in 3D with threaded assembly</a></h2><p>We will now look at an example where we assemble the stiffness matrix using multiple threads. We set up a simple grid and create a coloring, then create a DofHandler, and define the material stiffness</p><h4><a class="nav-anchor" id="Grid-for-the-beam-1" href="#Grid-for-the-beam-1">Grid for the beam</a></h4><div><pre><code class="language-julia">function create_colored_cantilever_grid(celltype, n)
    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))
    cell_colors, final_colors = JuAFEM.create_coloring(grid)
    return grid, final_colors
end;</code></pre></div><h4><a class="nav-anchor" id="DofHandler-1" href="#DofHandler-1">DofHandler</a></h4><div><pre><code class="language-julia">function create_dofhandler(grid::Grid{dim}) where {dim}
    dh = DofHandler(grid)
    push!(dh, :u, dim) # Add a displacement field
    close!(dh)
end;</code></pre></div><h3><a class="nav-anchor" id="Stiffness-tensor-for-linear-elasticity-1" href="#Stiffness-tensor-for-linear-elasticity-1">Stiffness tensor for linear elasticity</a></h3><div><pre><code class="language-julia">function create_stiffness(::Val{dim}) where {dim}
    E = 200e9
    ν = 0.3
    λ = E*ν / ((1+ν) * (1 - 2ν))
    μ = E / (2(1+ν))
    δ(i,j) = i == j ? 1.0 : 0.0
    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))
    C = SymmetricTensor{4, dim}(g);
    return C
end;</code></pre></div><h2><a class="nav-anchor" id="Threaded-data-structures-1" href="#Threaded-data-structures-1">Threaded data structures</a></h2><p>ScratchValues is a thread-local collection of data that each thread needs to own, since we need to be able to mutate the data in the threads independently</p><div><pre><code class="language-julia">struct ScratchValues{T, CV &lt;: CellValues, FV &lt;: FaceValues, TT &lt;: AbstractTensor, dim, Ti}
    Ke::Matrix{T}
    fe::Vector{T}
    cellvalues::CV
    facevalues::FV
    global_dofs::Vector{Int}
    ɛ::Vector{TT}
    coordinates::Vector{Vec{dim, T}}
    assembler::JuAFEM.AssemblerSparsityPattern{T, Ti}
end;</code></pre></div><p>Each thread need its own CellValues and FaceValues (although, for this example we don&#39;t use the FaceValues)</p><div><pre><code class="language-julia">function create_values(refshape, dim, order::Int)
    # Interpolations and values
    interpolation_space = Lagrange{dim, refshape, 1}()
    quadrature_rule = QuadratureRule{dim, refshape}(order)
    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)
    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];
    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];
    return cellvalues, facevalues
end;</code></pre></div><p>Create a <code>ScratchValues</code> for each thread with the thread local data</p><div><pre><code class="language-julia">function create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}
    nthreads = Threads.nthreads()
    assemblers = [start_assemble(K, f) for i in 1:nthreads]
    cellvalues, facevalues = create_values(RefCube, dim, 2)

    n_basefuncs = getnbasefunctions(cellvalues[1])
    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]

    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector
    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]

    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]

    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]

    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],
                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]
end;</code></pre></div><h2><a class="nav-anchor" id="Threaded-assemble-1" href="#Threaded-assemble-1">Threaded assemble</a></h2><p>The assembly function loops over each color and does a threaded assembly for that color</p><div><pre><code class="language-julia">function doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}

    f = zeros(ndofs(dh))
    scratches = create_scratchvalues(K, f, dh)
    b = Vec{3}((0.0, 0.0, 0.0)) # Body force

    for color in colors
        # Each color is safe to assemble threaded
        Threads.@threads for i in 1:length(color)
            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)
        end
    end

    return K, f
end</code></pre><pre><code class="language-none">doassemble (generic function with 1 method)</code></pre></div><p>The cell assembly function is written the same way as if it was a single threaded example. The only difference is that we unpack the variables from our <code>scratch</code>.</p><div><pre><code class="language-julia">function assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,
                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}

    # Unpack our stuff from the scratch
    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =
         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,
         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler

    fill!(Ke, 0)
    fill!(fe, 0)

    n_basefuncs = getnbasefunctions(cellvalues)

    # Fill up the coordinates
    nodeids = grid.cells[cell].nodes
    for j in 1:length(coordinates)
        coordinates[j] = grid.nodes[nodeids[j]].x
    end

    reinit!(cellvalues, coordinates)

    for q_point in 1:getnquadpoints(cellvalues)
        for i in 1:n_basefuncs
            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))
        end
        dΩ = getdetJdV(cellvalues, q_point)
        for i in 1:n_basefuncs
            δu = shape_value(cellvalues, q_point, i)
            fe[i] += (δu ⋅ b) * dΩ
            ɛC = ɛ[i] ⊡ C
            for j in 1:n_basefuncs
                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ
            end
        end
    end

    celldofs!(global_dofs, dh, cell)
    assemble!(assembler, global_dofs, fe, Ke)
end;

function run_assemble()
    refshape = RefCube
    quadrature_order = 2
    dim = 3
    n = 20
    grid, colors = create_colored_cantilever_grid(Hexahedron, n);
    dh = create_dofhandler(grid);

    K = create_sparsity_pattern(dh);
    C = create_stiffness(Val{3}());
    # compilation
    doassemble(K, colors, grid, dh, C);
    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);
    return b
end

run_assemble()</code></pre><pre><code class="language-none">  2.305885 seconds (174.72 k allocations: 6.367 MiB)
2.305975269</code></pre></div><p>Running the code with different number of threads give the following runtimes:</p><ul><li>1 thread  2.46 seconds</li><li>2 threads 1.19 seconds</li><li>3 threads 0.83 seconds</li><li>4 threads 0.75 seconds</li></ul><h2><a class="nav-anchor" id="threaded_assembly-plain-program-1" href="#threaded_assembly-plain-program-1">Plain Program</a></h2><p>Below follows a version of the program without any comments. The file is also available here: <a href="../threaded_assembly.jl">threaded_assembly.jl</a></p><pre><code class="language-julia">using JuAFEM, SparseArrays

function create_example_2d_grid()
    grid = generate_grid(Quadrilateral, (10, 10), Vec{2}((0.0, 0.0)), Vec{2}((10.0, 10.0)))
    cell_colors, colors = JuAFEM.create_coloring(grid)
    vtk_grid(&quot;colored&quot;, grid) do vtk
        JuAFEM.vtk_cell_data_colors(vtk, grid, colors)
    end
end;

create_example_2d_grid()

function create_colored_cantilever_grid(celltype, n)
    grid = generate_grid(celltype, (10*n, n, n), Vec{3}((0.0, 0.0, 0.0)), Vec{3}((10.0, 1.0, 1.0)))
    cell_colors, final_colors = JuAFEM.create_coloring(grid)
    return grid, final_colors
end;

function create_dofhandler(grid::Grid{dim}) where {dim}
    dh = DofHandler(grid)
    push!(dh, :u, dim) # Add a displacement field
    close!(dh)
end;

function create_stiffness(::Val{dim}) where {dim}
    E = 200e9
    ν = 0.3
    λ = E*ν / ((1+ν) * (1 - 2ν))
    μ = E / (2(1+ν))
    δ(i,j) = i == j ? 1.0 : 0.0
    g(i,j,k,l) = λ*δ(i,j)*δ(k,l) + μ*(δ(i,k)*δ(j,l) + δ(i,l)*δ(j,k))
    C = SymmetricTensor{4, dim}(g);
    return C
end;

struct ScratchValues{T, CV &lt;: CellValues, FV &lt;: FaceValues, TT &lt;: AbstractTensor, dim, Ti}
    Ke::Matrix{T}
    fe::Vector{T}
    cellvalues::CV
    facevalues::FV
    global_dofs::Vector{Int}
    ɛ::Vector{TT}
    coordinates::Vector{Vec{dim, T}}
    assembler::JuAFEM.AssemblerSparsityPattern{T, Ti}
end;

function create_values(refshape, dim, order::Int)
    # Interpolations and values
    interpolation_space = Lagrange{dim, refshape, 1}()
    quadrature_rule = QuadratureRule{dim, refshape}(order)
    face_quadrature_rule = QuadratureRule{dim-1, refshape}(order)
    cellvalues = [CellVectorValues(quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];
    facevalues = [FaceVectorValues(face_quadrature_rule, interpolation_space) for i in 1:Threads.nthreads()];
    return cellvalues, facevalues
end;

function create_scratchvalues(K, f, dh::DofHandler{dim}) where {dim}
    nthreads = Threads.nthreads()
    assemblers = [start_assemble(K, f) for i in 1:nthreads]
    cellvalues, facevalues = create_values(RefCube, dim, 2)

    n_basefuncs = getnbasefunctions(cellvalues[1])
    global_dofs = [zeros(Int, ndofs_per_cell(dh)) for i in 1:nthreads]

    fes = [zeros(n_basefuncs) for i in 1:nthreads] # Local force vector
    Kes = [zeros(n_basefuncs, n_basefuncs) for i in 1:nthreads]

    ɛs = [[zero(SymmetricTensor{2, dim}) for i in 1:n_basefuncs] for i in 1:nthreads]

    coordinates = [[zero(Vec{dim}) for i in 1:length(dh.grid.cells[1].nodes)] for i in 1:nthreads]

    return [ScratchValues(Kes[i], fes[i], cellvalues[i], facevalues[i], global_dofs[i],
                         ɛs[i], coordinates[i], assemblers[i]) for i in 1:nthreads]
end;

function doassemble(K::SparseMatrixCSC, colors, grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}) where {dim}

    f = zeros(ndofs(dh))
    scratches = create_scratchvalues(K, f, dh)
    b = Vec{3}((0.0, 0.0, 0.0)) # Body force

    for color in colors
        # Each color is safe to assemble threaded
        Threads.@threads for i in 1:length(color)
            assemble_cell!(scratches[Threads.threadid()], color[i], K, grid, dh, C, b)
        end
    end

    return K, f
end

function assemble_cell!(scratch::ScratchValues, cell::Int, K::SparseMatrixCSC,
                        grid::Grid, dh::DofHandler, C::SymmetricTensor{4, dim}, b::Vec{dim}) where {dim}

    # Unpack our stuff from the scratch
    Ke, fe, cellvalues, facevalues, global_dofs, ɛ, coordinates, assembler =
         scratch.Ke, scratch.fe, scratch.cellvalues, scratch.facevalues,
         scratch.global_dofs, scratch.ɛ, scratch.coordinates, scratch.assembler

    fill!(Ke, 0)
    fill!(fe, 0)

    n_basefuncs = getnbasefunctions(cellvalues)

    # Fill up the coordinates
    nodeids = grid.cells[cell].nodes
    for j in 1:length(coordinates)
        coordinates[j] = grid.nodes[nodeids[j]].x
    end

    reinit!(cellvalues, coordinates)

    for q_point in 1:getnquadpoints(cellvalues)
        for i in 1:n_basefuncs
            ɛ[i] = symmetric(shape_gradient(cellvalues, q_point, i))
        end
        dΩ = getdetJdV(cellvalues, q_point)
        for i in 1:n_basefuncs
            δu = shape_value(cellvalues, q_point, i)
            fe[i] += (δu ⋅ b) * dΩ
            ɛC = ɛ[i] ⊡ C
            for j in 1:n_basefuncs
                Ke[i, j] += (ɛC ⊡ ɛ[j]) * dΩ
            end
        end
    end

    celldofs!(global_dofs, dh, cell)
    assemble!(assembler, global_dofs, fe, Ke)
end;

function run_assemble()
    refshape = RefCube
    quadrature_order = 2
    dim = 3
    n = 20
    grid, colors = create_colored_cantilever_grid(Hexahedron, n);
    dh = create_dofhandler(grid);

    K = create_sparsity_pattern(dh);
    C = create_stiffness(Val{3}());
    # compilation
    doassemble(K, colors, grid, dh, C);
    b = @elapsed @time K, f = doassemble(K, colors, grid, dh, C);
    return b
end

run_assemble()

# This file was generated using Literate.jl, https://github.com/fredrikekre/Literate.jl</code></pre><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../incompressible_elasticity/"><span class="direction">Previous</span><span class="title">Incompressible Elasticity</span></a><a class="next" href="../../../reference/quadrature/"><span class="direction">Next</span><span class="title">Quadrature</span></a></footer></article></body></html>
